diff -up scribus-1.5.8/cmake/modules/Findpoppler.cmake.8~ scribus-1.5.8/cmake/modules/Findpoppler.cmake
--- scribus-1.5.8/cmake/modules/Findpoppler.cmake.8~	2022-08-10 22:16:08.893234783 +0200
+++ scribus-1.5.8/cmake/modules/Findpoppler.cmake	2022-08-10 22:16:08.924233990 +0200
@@ -1,8 +1,8 @@
 #include(FindPkgConfig)
 find_package(PkgConfig QUIET)
-pkg_search_module(poppler libpoppler>=0.86.0 poppler>=0.86.0)
+pkg_search_module(poppler libpoppler>=21.03.0 poppler>=21.03.0)
 if (poppler_FOUND)
-	pkg_search_module(poppler_cpp REQUIRED libpoppler-cpp>=0.86.0 poppler-cpp>=0.86.0)
+	pkg_search_module(poppler_cpp REQUIRED libpoppler-cpp>=21.03.0 poppler-cpp>=21.03.0)
 endif(poppler_FOUND)
  
 find_path(poppler_INCLUDE_DIR
diff -up scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.cpp.8~ scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.cpp
--- scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.cpp.8~	2022-08-10 22:16:08.915234220 +0200
+++ scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.cpp	2022-08-10 22:17:43.797809109 +0200
@@ -2197,18 +2197,12 @@ bool SlaOutputDev::patchMeshShadedFill(G
 	return true;
 }
 
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
-#else
-bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, Object *str, const double *pmat, int /*paintType*/, int /*tilingType*/, Dict *resDict, const double *mat, const double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep)
-#endif
 {
 //	qDebug() << "SlaOutputDev::tilingPatternFill";
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	const double *bbox = tPat->getBBox();
 	const double *pmat = tPat->getMatrix();
 	Dict *resDict = tPat->getResDict();
-#endif
 
 	PDFRectangle box;
 	Gfx *gfx;
@@ -2236,17 +2230,11 @@ bool SlaOutputDev::tilingPatternFill(Gfx
 	// Unset the clip path as it is unrelated to the pattern's coordinate space.
 	QPainterPath savedClip = m_currentClipPath;
 	m_currentClipPath = QPainterPath();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	gfx->display(tPat->getContentStream());
-#else
-	gfx->display(str);
-#endif
 	m_currentClipPath = savedClip;
 	inPattern--;
-	gElements = m_groupStack.pop();
 	m_doc->m_Selection->clear();
-//	double pwidth = 0;
-//	double pheight = 0;
+	gElements = m_groupStack.pop();
 	if (gElements.Items.count() > 0)
 	{
 		for (int dre = 0; dre < gElements.Items.count(); ++dre)
@@ -2271,8 +2259,6 @@ bool SlaOutputDev::tilingPatternFill(Gfx
 		m_doc->DoDrawing = false;
 		pat.width = ite->width();
 		pat.height = ite->height();
-	//	pwidth = ite->width();
-	//	pheight = ite->height();
 		ite->gXpos = 0;
 		ite->gYpos = 0;
 		ite->setXYPos(ite->gXpos, ite->gYpos, true);
diff -up scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.h.8~ scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.h
--- scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.h.8~	2022-08-10 22:16:08.915234220 +0200
+++ scribus-1.5.8/scribus/plugins/import/pdf/slaoutput.h	2022-08-10 22:16:08.925233964 +0200
@@ -190,11 +190,7 @@ public:
 	void stroke(GfxState *state) override;
 	void fill(GfxState *state) override;
 	void eoFill(GfxState *state) override;
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
-#else
-	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, Object *str, const double *pmat, int paintType, int tilingType, Dict *resDict, const double *mat, const double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
-#endif
 	bool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return false; }
 	bool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
 	bool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
